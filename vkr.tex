% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macroses see also
% https://tex.stackexchange.com/questions/78101/

\input{header.tex}
\input{header2.tex}

\usepackage{totcount}

\usepackage{caption}
\usepackage{listings}

\DeclareCaptionFont{white}{ \color{white} }
\DeclareCaptionFormat{listing}{
    \parbox{\textwidth}{\hspace{15pt}#1#2#3}
}
% \captionsetup[lstlisting]{ format=listing
%   %, labelfont=white, textfont=white
%   , singlelinecheck=false, margin=0pt, font={bf}
% }

\begin{document}
\input{title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

% \begin{abstract}
%   В курсаче не нужен
% \end{abstract}

\section*{Введение}
\input{000intro}

\section{Постановка задачи}
\input{010task}

\section{Обзор}
\input{020related}

\section{Обзор используемых инструментов}
\input{instruments}

% \section{Background (опционально)}
% Здесь пишется некоторая дополнительная информация о том, зачем делается то, что делается.

% Например, в работе придумывается какой-то новый метод решения формул в \SMT{} в теориях с числами. Без каких-то дополнительных пояснений будет казаться, что работа состоит из жестокого ``матана'' и совсем не по теме кафедры системного программирования. 
% Поэтому, в данном разделе стоит рассказать, что все эти методы примеряются для верификации в проекте \vsharp{}, и поэтому непосредственно связаны с тематикой кафедры.


% \section{Метод}
% \input{040method}


% \section{Эксперимент}
% \input{070experiment}

% \section{Применение (того, что сделано на практике)}

% Если применение в лоб не работает, потому что всё изложено чуть более сжато и теоретично, надо рассказать тонкости и правильный метод применения результатов. Если результаты применяются без дополнительных телодвижений, то про это можно не писать.

% \section{Угрозы нарушения корректности (опциональный)}

% Если основная заслуга метода, это то, что он дает лучшие цифры, то стоит сказать, где мы могли облажаться, когда
% \begin{enumerate}
% \item проводили численные замеры;
% \item выбирали тестовый набор (см. \emph{confirmation bias})
% \end{enumerate} 

\section{Реализация}
Для практической реализации использовался текстовый редактор Visual Studio Code и открытый репозиторий на GitHub.

\subsection{Проектирование сервиса} 
После анализа аналогов, был сделан вывод, что за основу стоит взять CloudShark, так как его интерфейс максимально приближен к Wireshark.
Для реализация серверной части был использован фреймворк Flask.
Для версти веб-страницы был выбран Bootstrap.
Для парсинга пакетов была использована библиотека для Python -- dpkt.
Основной причиной выбора этих библиотек и фреймворков послужило то, что они были использованы при создании Miminet.
Все pcap файлы после обработки представляли JSON (JavaScript Object
Notation) файл, с помощью которого удобно передавать информацию в html часть сервиса.

Схема работы сервиса:
\begin{figure}[!ht]
  \begin{center}
  \includegraphics[scale=1.3]{Scheme_of_project.png}\caption{Схема обработки файлов на сервере}\label{figure2}
  \end{center}
\end{figure}


\subsection{Реализация серверной части} 
Испольщование Flask помогло без проблем созать серверную часть. Помог также встроенный в него шаблонизатор Jinja.
Благодаря ему, можно с легкостью передавать в html обработанные в json pcap файлы.
Учитывая, что Miminet написан на Flask, готовый продукт без труда можно было подключить в качестве новой вкладки.

Ниже представлен Flask декоратор -- функция, которая запускает страницу проекта:
\begin{lstlisting}[caption=\textbf{Основной декоратор}, language=Python, frame=single]
  @app.route('/MimiShark')
  def main_page():
    data = ReadJson(path)
    return render_template('main.html',pcap_data = data)
\end{lstlisting}

В этой функции происходит считывание заготовленного json файла, а далее рендер нужной html страницы, с переданными данными.

Далее представлена работа шаблонизатора Jinja:
\begin{lstlisting}[caption=\textbf{Передача pcap файлов в html}, language=HTML, frame=single]
  {% block pcap %}
  {% for el in pcap_data %}
  <tr id="{{loop.index}}">
    <th scope="row">{{loop.index}}</th>
    <td>{{el.time}}</td>
    <td>{{el.source}}</td>
    <td>{{el.destination}}</td>
    <td>{{el.protocol}}</td>
    <td>{{el.length}}</td>
  </tr>
  {%endfor%}
  {% endblock %}
\end{lstlisting}

Здесь представлен блок кода (block pcap), 
который будет отображен на веб-странице, 
в нем с помощью цикла, выводятся все файлы, полученные в качестве переменной 
pcap data из предыдущего листинга.


\subsection{Реализация графической составляющей} 
Как уже говорилось в обзоре используемых инструментов, с помощью Bootstrap, можно легко созать шаблон сайта за короткое время.
Так как Miminet также был написан на Bootstrap, было принято решение сделать страницу по стилю, максимально приближенному к стилю Miminet.
Поначалу задумывалось использовать приложение Figma для составления наброска сайта.
Но интерфейс сайта был настолько легким в реализациии, а шаблоны Bootstrap в освоении., что использование Figma было излишним.



Макет сайта по собранной информации:
\begin{figure}[!ht]
  \begin{center}
  \includegraphics[scale=0.6]{layout.png}\caption{Макет сайта}\label{figure1}
  \end{center}
\end{figure}


\newpage
Конечная версия сайта выглядит так:
\begin{figure}[!ht]
  \begin{center}
  \includegraphics[scale=0.4]{cite.jpg}\caption{Внешний вид сайта}\label{figure2}
  \end{center}
\end{figure}

Также для написания сайта использовался JavaScript. С его помощью были написаны функции вывода данных при нажатии по файлу из таблицы.



\subsection{Парсинг и передача пакетов на сайт} 
Чтобы проверить правильность написания парсера, из Wireshark были экспортированные некоторые pcap файлы.
Благодаря библиотеке dpkt из них легко можно было достать нужную информацию:
Ethernet данные файла(место назначения переданных данных,
место, откуда эти данные были переданы, его тип),
версию и другие полезные данные интернет протокола,
а также все данные протокола управления передачей.

На листинге представлена функция получения всех данных о протоколах:
\begin{lstlisting}[caption=\textbf{Получение данных из протоколов}, language=Python, frame=single]
  import dpkt
  def protocol_prop(self):
    l_ = []
    
    def add_field(fn, fv):
      l_.append('%s=%s,' % (fn, fv))

    for field_name in self.__public_fields__:
        if isinstance (self, dpkt.tcp.TCP):
            tcp = self
            d = {dpkt.tcp.TH_FIN:'FIN', dpkt.tcp.TH_SYN:'SYN', 
            dpkt.tcp.TH_RST:'RST', dpkt.tcp.TH_PUSH:'PUSH', 
            dpkt.tcp.TH_ACK:'ACK', dpkt.tcp.TH_URG:'URG'}
            active_flags = filter(lambda t: 
                                  t[0] & tcp.flags, d.items())
            flags_str = '+'.join(t[1] for t in active_flags)
            flag = f'({str(flags_str)})'

        add_field(field_name, getattr(self, field_name))

    ip_prot = '%s:' % self.__class__.__name__  
    for ii in l_:
        ip_prot += '%s' % ii
    return ip_prot
\end{lstlisting}
В функции protocol properties есть дополнительная функция добавления поля с его значением в лист, из которого они в дальнейшем будут считываться в ответ.
Далее функция проходит циклом по всем полям, при этом происходит проверка: если переданный файл содержит tcp протокол, то выводим нужное имя флага.
Также в цикле определяются значения полей и добавляются в список для отображения.
В конце функции, собранные данные из списка, добавляются в ответ, который по итогу функция возвращает. 

На этом листинге представлен парсер, основанный на dpkt:
\begin{lstlisting}[caption=\textbf{Работа парсера pcap файлов}, language=Python, frame=single]
  def add_packets(pcap):
    with open("pcap.json","w") as file:
        for  timestamp, buf in pcap:
            pcap_file = {}
            eth = dpkt.ethernet.Ethernet(buf)

            if not isinstance(eth.data, dpkt.ip.IP):
                continue
            
            pcap_file["time"] = str(datetime.datetime
                              .utcfromtimestamp(timestamp))

            ip = eth.data
            pcap_file["source"] = inet_to_str(ip.src)
            pcap_file["destination"] = inet_to_str(ip.dst)
            pcap_file["protocol"] = ip.get_proto(ip.p).__name__
            pcap_file["length"] = ip.len
            
            bytes_repr = ' '.join(mac_to_str(buf).split(':'))

            ascii = ''
            for i in bytes_repr.split(' '):
                a = bytes.fromhex(i)
                b = str(a)[2:len((str(a)))-1]
                if(len(b)<2):
                    ascii += b
                else:
                    ascii+= '.'
            pcap_file["ascii"] = ascii
            pcap_file["bytes"] = bytes_repr

            pcap_file["decode_eth"] = '%s:%s:%s' % 
            (mac_to_str(eth.dst), 
            mac_to_str(eth.src), bytes_repr[36:41])
            pcap_file["decode_ip"] = ip_protocol_prop(ip)
            pcap_file[f"decode_{ip.data}"] = 
                                ip_protocol_prop(ip.data)

            json_file.append(pcap_file)
        print(json.dumps(json_file), file=file)
\end{lstlisting}
Перед вызовом этой функции идет открытие и считывание pcap файлов. В функции происходит следующее: 

Для каждого пакета из pcap обрабатывается содержимое.
Распаковывается ethernet frame. Достается ip пакетов и байты. Далее байты сопоставляются с ascii таблицей.
А также подробно описываются данные файлов.
Обработанные файлы отправляются в созданный json.

\subsection{Внедрение готового проекта в Miminet}
Завершающей частью работы была интеграция готового продукта в приложение Miminet.
Для выполнения этой задачи была изменена не только сктруктура файлов проекта, но и исходные файлы Miminet. 
С помощью шаблонизатора Jinja веб-страница анализатора была перебазирована под стиль, который используется разработчиками Miminet.
Переход на страницу анализатора происходит по добавленной для каждого компонента ссылке, которая содержит
свой маршрут -- 
\newline
/MimiShark?guid=...,
где guid --  статистически уникальный 128-битный идентификатор, присваиваемый каждому конструктору сети.
На странице выводятся файлы, содержащиеся в компоненте.


% \begin{enumerate}
% \item Реализация должна быть. На публично доступную реализацию обязательная ссылка. Если код под \textsc{NDA}, то об этом, во-первых, должно быть сказано явно, и, во-вторых, на защиту должны выноситься другие результаты (например, архитектура), чтобы комиссия имела возможность оценить хоть что-то.
% \begin{itemize}
% \item  Рецензент обязан оценить код (о возможности должен побеспокоиться обучающийся).
% \end{itemize} 
% \item Код реализации должен быть написан защищающимся целиком.
% \begin{itemize}
% \item  Если проект групповой, то нужно явно выделить какие части были модифицированы защищающимся. Например, в предыдущих разделах на картинке архитектуры нужно выделить цветом то, что вы модифицировали.
% \item Нельзя пускать в негрупповой проект коммиты от других людей, или людей не похожих на Вас. Например, в 2022 году защищающийся-парень делал коммиты от сценического псевдонима, который намекает на женский ``гендер''. (Нет, это не шутка.) На тот момент в российской культуре это выглядело странно.
% \item Возможна ситуация, что вы используете конкретный ник в интернете уже лет пять, и желаете писать ВКР под этим ником на \GitHub{}. В принципе, это допустимо (не только лишь я так считаю), но если Вы встретите преподавателя, который считает наоборот, то Вам придется грамотно отмазываться. В Вашу пользу могут сыграть те факты, что к нику на гитхабе у Вас приписаны настоящие имя и фамилия; что в репозитории у вас видна домашка за 1й курс; и что Ваш преподаватель практики сможет подтвердить, что Вы уже несколько лет используете это ник; и т.п.
% \end{itemize} 
% \item Если вы получаете диплом о присвоении звания программного инженера, код должен соответствовать. 
% \begin{enumerate}
% \item Не стоит выкладывать код одним коммитом.
% \item Лучше хоть какие-то тесты, чем совсем без них. В идеале нужно предъявлять процент покрытия кода тестами.
% \item Лучше  сделать \textsc{CI}, а также \textsc{CD}, если оно уместно в Вашем проекте.
% \item Не стоит демонстрировать на защите, что Вам даже не пришло в голову напустить на код линтеры и т.п.
% \end{enumerate}
% \item Если ваша реализация по сути является прохождением стандартного туториала, например, по отделению картинок кружек от котиков с помощью машинного обучения, то необходимо срочно сообщить об этом куратору на мат-мехе, иначе Государственная Экзаменационная Комиссия ``порвёт Вас как Тузик грелку'', поставит ``единицу'', а все остальные Ваши сокурсники получат оценку выше. (Это не шутка, а реальная история 2020 года.)
% \item 
% \end{enumerate}

% \noindent Если Вам предстоит защищать учебную практику, а эти рекомендации видятся как более подходящие для защиты ВКР, то ... отмаза не засчитывается, сразу учитесь делать нормально.
\section*{Заключение}
\input{090conclusion}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
  \bibliographystyle{ugost2008ls}
  \bibliography{vkr}
\end{document}
