% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macroses see also
% https://tex.stackexchange.com/questions/78101/

\input{header.tex}
\input{header2.tex}

\usepackage{totcount}

\usepackage{caption}
\usepackage{listings}

\DeclareCaptionFont{white}{ \color{white} }
\DeclareCaptionFormat{listing}{
    \parbox{\textwidth}{\hspace{15pt}#1#2#3}
}
\captionsetup[lstlisting]{ format=listing
  %, labelfont=white, textfont=white
  , singlelinecheck=false, margin=0pt, font={bf}
}

\begin{document}
\input{title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

% \begin{abstract}
%   В курсаче не нужен
% \end{abstract}

\section*{Введение}
\input{000intro}

\section{Постановка задачи}
\input{010task}

% \section{Обзор}
% \input{020related}

\section*{3. Обзор используемых инструментов}
\input{instruments}

% \section{Background (опционально)}
% Здесь пишется некоторая дополнительная информация о том, зачем делается то, что делается.

% Например, в работе придумывается какой-то новый метод решения формул в \SMT{} в теориях с числами. Без каких-то дополнительных пояснений будет казаться, что работа состоит из жестокого ``матана'' и совсем не по теме кафедры системного программирования. 
% Поэтому, в данном разделе стоит рассказать, что все эти методы примеряются для верификации в проекте \vsharp{}, и поэтому непосредственно связаны с тематикой кафедры.


% \section{Метод}
% \input{040method}


% \section{Эксперимент}
% \input{070experiment}

% \section{Применение (того, что сделано на практике)}

% Если применение в лоб не работает, потому что всё изложено чуть более сжато и теоретично, надо рассказать тонкости и правильный метод применения результатов. Если результаты применяются без дополнительных телодвижений, то про это можно не писать.

% \section{Угрозы нарушения корректности (опциональный)}

% Если основная заслуга метода, это то, что он дает лучшие цифры, то стоит сказать, где мы могли облажаться, когда
% \begin{enumerate}
% \item проводили численные замеры;
% \item выбирали тестовый набор (см. \emph{confirmation bias})
% \end{enumerate} 

\section{Реализация}
Для практической реализации использовался текстовый редактор Visual Studio Code и открытый репозиторий в GitHub.

Самой сложной частью выполнения проекта стало освоение новых, ранее неизвестных языков: miniKanren и OCaml (Изучал я их по книгам~\cite{reasoned_schemer}~\cite{prog_ocaml})
Для примера, приведу базовое отношение в miniKanren append$^o$ --- конкатенации списков. А также для сравнения ее реализацию, но уже в OCaml:


\begin{lstlisting}[caption=Append$^o$, frame=single]
  (defrel (appendo l t out)
    (conde
      ((nullo l) (== t out))
      ((fresh (res)
        (fresh (d)
          (cdro l d)
          (appendo d t
          res))
        (fresh (a)
          (caro l a)
          (conso a res
          out))))))
\end{lstlisting}

\begin{lstlisting}[caption=Append$^o$, language=OCaml, frame=single]
  Conde
    [ Conj [ Unify (Var "xs", Nil); Unify (Var "ys", Var "xys") ]
    ; Fresh
      ( "h"
     , Fresh
         ( "tmp"
        , Fresh
          ( "tl"
          , Conj
            [ Unify (Cons (Var "h", Var "tl"), Var "xs")
            ; Unify (Cons (Var "h", Var "tmp"), Var "xys")
            ; Call ("appendo", [ Var "tl"; Var "ys"; Var "tmp" ])
            ] ) ) )
    ]
\end{lstlisting}

Теперь не возникнет вопросов, почему на это ушло так много времени

Для освоения способов применения мною были изучены предложенные примеры параллельного сложения матриц
и рассмотренна реализация чисел Фибоначчи, которая тоже была распараллелена

\begin{lstlisting}[caption=Domainslib, language=OCaml, frame=single]
  let parallel_matrix_multiply pool a b =
  let i_n = Array.length a in
  let j_n = Array.length b.(0) in
  let k_n = Array.length b in
  let res = Array.make_matrix i_n j_n 0 in

  Task.parallel_for pool ~start:0 ~finish:(i_n - 1)
   ~body:(fun i ->
    for j = 0 to j_n - 1 do
      for k = 0 to k_n - 1 do
        res.(i).(j) <- res.(i).(j) + a.(i).(k) * b.(k).(j)
      done
    done);
  res

  let rec fib_par pool n =
  if n <= 40 then fib n
  else
    let a = Task.async pool (fun _ -> fib_par pool (n-1)) in
    let b = Task.async pool (fun _ -> fib_par pool (n-2)) in
    Task.await pool a + Task.await pool b
  
  let c = Chan.make_bounded 0

  let _ =
    let send = Domain.spawn(fun _ ->
            let b = Chan.send_poll c "hello" in
            Printf.printf "%B\n" b) in
    Domain.join send;
\end{lstlisting}

В этой работе есть возможность параллелить только дизъюнкцию (Cond$^e$), так как это выполнение двух независимых задач,
в то время как все остальное -- зависимые задачи и нет осознания того, как их параллелить

Задачи, которые мне предстояло выполнить:
\begin{itemize}
  \item Параллельный запуск append$^o$
\item Параллельный запуск revers$^o$ 
\item Параллельный запуск некоторых функций, которые возвращают
несколько ответов
\item Последней задачей оказалось слияние Stream’ов: Хотим доставать
ответы по мере поступаления изнутри функции и вытягивать их на
верхний уровень(в ответ)
\end{itemize}

Пример внешней параллелизации 2х revers$^o$ на списках длины 700 каждый:

\begin{lstlisting}[caption=parallel revers$^o$, language=OCaml, frame=single]
  let goal = Call ("reverso", [ len; Var "xs" ]) in
  let goal2 = Call ("reverso", [ len; Var "xz" ]) in
  let state0 =
    State.(
      empty
      |> "xs" --> Var 10
      |> add_rel "appendo" [ "xs"; "ys"; "xys" ] appendo_body
      |> add_rel "reverso" [ "xy"; "yx" ] reverso_body)
  in
  let state1 =
    State.(
      empty
      |> "xz" --> Var 10
      |> add_rel "appendo" [ "xs"; "ys"; "xys" ] appendo_body
      |> add_rel "reverso" [ "xy"; "yx" ] reverso_body)
  in
  let wrap g =
    let s = StateMonad.run (eval first_logic g) state0 in
    (* let _ = Result.map (Stream.take ~n:1) s in ~trace_uni:true*)
    s
  in
  let wrap1 g =
    let s = StateMonad.run (eval second_logic g) state1 in
    s
  in
  let pool = Task.setup_pool ~num_domains:2 () in
  let d = Task.async pool (fun _ -> wrap goal) in
  let d1 = Task.async pool (fun _ -> wrap1 goal2) in
  match Task.run pool (fun () -> Task.await pool d,
                           Task.await pool d1) with
  | Result.Ok a, Result.Ok b ->
    (a
    |> Stream.take ~n:(-1)
    |> fun xs -> Format.printf "Got %d answers\n%!"
                       (List.length xs));
    b
    |> Stream.take ~n:(-1)
    |> fun xs -> Format.printf "Got %d answers\n%!"
                       (List.length xs)
  | Ok _, Error _ | Error _, Ok _ | Error _, Error _ ->
    failwithf "%s %d" __FILE__ __LINE__
\end{lstlisting}

Пример форсирования и слияние stream:

\begin{lstlisting}[caption=merge stream, language=OCaml, frame=single]
  let rec merge_Stream n =
  let open StateMonad.Syntax in
  let open StateMonad in
  let* st = read in
  match Chan.recv_poll c with
  | Some x ->
    let* () = put st in
    return (Stream.mplus (Stream.return x)) 
                          <*> merge_Stream n
  | None -> return Stream.Nil
;;

let rec force_Stream x =
  match x with
  | Stream.Cons (x, y) ->
    Chan.send c x;
    force_Stream (Lazy.force y)
  | Stream.Nil -> ()
  | _ -> assert false
;;
\end{lstlisting}

Изначальная версия Cond$^e$:


\begin{lstlisting}[caption=parallel cond$^e$, language=OCaml, frame=single]
  let* st = read in
      List.foldlm
        (fun acc y ->
          let* () = put st in
          return (Stream.mplus acc) <*> (eval y))
        (eval x)
        xs
\end{lstlisting}

Но это все была лишь подготовка для того, что бы начать полноценную встроенную параллелизацию Cond$^e$ 

Для этого было необходимо заменить mplus на синхронный опрос канала (Chan). Вот что у меня вышло:

\begin{lstlisting}[caption=Parallel Cond$^e$, language=OCaml, frame=single]
  let c = Chan.make_unbounded () in
      let rec force_stream x =
        match x with
        | Stream.Cons (x, y) ->
          Chan.send c x;
          force_stream (Lazy.force y)
        | Stream.Nil -> ()
        | _ -> assert false
      in
      let* st = read in
      let pool = Task.setup_pool ~num_domains:12 () in
      let rec merge_stream n =
        match Chan.recv_poll c with
        | Some x ->
          let* () = put st in
          return (Stream.mplus (Stream.return x)) <*> merge_stream n
        | None -> return Stream.Nil
      in
      let make_task acc =
        Task.async pool (fun _ ->
          force_stream (StateMonad.run (eval acc) st |> Result.get_ok))
      in
      let make_task_list lst =

        Stdlib.List.map make_task lst
      in
      Task.run pool (fun () ->
        Stdlib.List.iter (fun x -> Task.await pool x) (make_task_list lst));
      merge_stream c
\end{lstlisting}


\section{Тестирование}

\begin{lstlisting}[caption=Tests, language=OCaml, frame=single]
  (let goal =
    CondePar
      [ Call ("appendo", [ Var "xs"; Var "ys"; len ])
      ; Call ("appendo", [ Var "xs"; Var "ys"; len ])
      ]
  in
  let env =
    State.(
      empty
      |> "xs" --> Var 9
      |> "ys" --> Var 10
      |> add_rel "appendo" [ "xs"; "ys"; "xys" ] appendo_body)
  in
  let a = StateMonad.run (eval goal) env in
  match a with
  | Result.Ok a ->
    a
    |> Stream.take ~n:(-1)
    |> fun xs -> Format.printf "Got %d answers\n%!" 
                  (List.length xs)
  | Error _ -> failwithf "%s %d" __FILE__ __LINE__);
;;
\end{lstlisting}

\begin{figure}[h]

  \centering
  
  \includegraphics[width=0.8\linewidth]{1test.jpg}
  
  \caption{Входные данные: Параллельно запущены 2 append$^o$ на списках длины 7000 каждый.
  Количество потоков: 2}
  
  \label{fig:mpr}
  
\end{figure}
\begin{figure}[h]

  \centering
    
  \includegraphics[width=0.8\linewidth]{2test.jpg}
    
  \caption{Входные данные: Параллельно запущены 2 append$^o$ на списках длины 8000 каждый.
  Количество потоков: 12}
    
  \label{fig:mpr}
    
\end{figure}

После нескольких экспериментов, сделан вывод, что запускать при малом количестве потоков, а также на малых обьемах данных не так выгодно, но при росте количества потоков пользы заметно больше.

В результате проведенных тестов я обнаружил, что моя реализация работает не идеально. Если запускать программу, которая рекурсивно вызывает более 70 унификаций, то компилятор выдает ошибку: Task.run.loop
В дальнейших планах доработать эту неисправность и сделать рефакторинг существуюшей реализации
% \begin{enumerate}
% \item Реализация должна быть. На публично доступную реализацию обязательная ссылка. Если код под \textsc{NDA}, то об этом, во-первых, должно быть сказано явно, и, во-вторых, на защиту должны выноситься другие результаты (например, архитектура), чтобы комиссия имела возможность оценить хоть что-то.
% \begin{itemize}
% \item  Рецензент обязан оценить код (о возможности должен побеспокоиться обучающийся).
% \end{itemize} 
% \item Код реализации должен быть написан защищающимся целиком.
% \begin{itemize}
% \item  Если проект групповой, то нужно явно выделить какие части были модифицированы защищающимся. Например, в предыдущих разделах на картинке архитектуры нужно выделить цветом то, что вы модифицировали.
% \item Нельзя пускать в негрупповой проект коммиты от других людей, или людей не похожих на Вас. Например, в 2022 году защищающийся-парень делал коммиты от сценического псевдонима, который намекает на женский ``гендер''. (Нет, это не шутка.) На тот момент в российской культуре это выглядело странно.
% \item Возможна ситуация, что вы используете конкретный ник в интернете уже лет пять, и желаете писать ВКР под этим ником на \GitHub{}. В принципе, это допустимо (не только лишь я так считаю), но если Вы встретите преподавателя, который считает наоборот, то Вам придется грамотно отмазываться. В Вашу пользу могут сыграть те факты, что к нику на гитхабе у Вас приписаны настоящие имя и фамилия; что в репозитории у вас видна домашка за 1й курс; и что Ваш преподаватель практики сможет подтвердить, что Вы уже несколько лет используете это ник; и т.п.
% \end{itemize} 
% \item Если вы получаете диплом о присвоении звания программного инженера, код должен соответствовать. 
% \begin{enumerate}
% \item Не стоит выкладывать код одним коммитом.
% \item Лучше хоть какие-то тесты, чем совсем без них. В идеале нужно предъявлять процент покрытия кода тестами.
% \item Лучше  сделать \textsc{CI}, а также \textsc{CD}, если оно уместно в Вашем проекте.
% \item Не стоит демонстрировать на защите, что Вам даже не пришло в голову напустить на код линтеры и т.п.
% \end{enumerate}
% \item Если ваша реализация по сути является прохождением стандартного туториала, например, по отделению картинок кружек от котиков с помощью машинного обучения, то необходимо срочно сообщить об этом куратору на мат-мехе, иначе Государственная Экзаменационная Комиссия ``порвёт Вас как Тузик грелку'', поставит ``единицу'', а все остальные Ваши сокурсники получат оценку выше. (Это не шутка, а реальная история 2020 года.)
% \item 
% \end{enumerate}

% \noindent Если Вам предстоит защищать учебную практику, а эти рекомендации видятся как более подходящие для защиты ВКР, то ... отмаза не засчитывается, сразу учитесь делать нормально.
\section*{Заключение}
\input{090conclusion}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
  \bibliographystyle{ugost2008ls}
  \bibliography{vkr}
\end{document}
